<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>odin on gingerBill</title>
    <link>/tags/odin/</link>
    <description>Recent content in odin on gingerBill</description>
    <language>en-gb</language>
    <lastBuildDate>Mon, 22 Jan 2024 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="/tags/odin/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Why I Hate Language Benchmarks</title>
      <link>/article/2024/01/22/comparing-language-benchmarks/</link>
      <pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>/article/2024/01/22/comparing-language-benchmarks/</guid>
      <description>[Originally from a Twitter Thread]
Original Twitter Post
I don&amp;rsquo;t know if I have &amp;ldquo;ranted&amp;rdquo; about this here before but:
I absolutely HATE comparing programming languages with &amp;ldquo;benchmarks&amp;rdquo;.
Language benchmarks rarely ever actually test for anything useful when comparing one language against another. This goes for ANY language.
Even in the best case scenario: you are comparing different compilers for the same language (and the same input). This means that you are just comparing how well the optimizing backends work for those compilers.</description>
    </item>
    
    <item>
      <title>Reverse Engineering Alembic</title>
      <link>/article/2022/07/11/reverse-engineering-alembic/</link>
      <pubDate>Mon, 11 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>/article/2022/07/11/reverse-engineering-alembic/</guid>
      <description>For my work at JangaFX, we require the use of the Alembic interchange file format. We have been using other libraries which wrap reading the Alembic file format but because it is not the native library, it has numerous issues due to the generic interface.
I spent nearly 4 days trying to get the official Alembic C++ API, https://github.com/alembic/alembic/, to compile correctly and then use the API itself. Numerous times the compilation would get corrupted (it compiled but none of the tests even ran) and when I got it work (on another machine), the API itself was a labyrinth to navigate.</description>
    </item>
    
    <item>
      <title>Multiple Return Values Research</title>
      <link>/article/2021/12/15/multiple-return-values-research/</link>
      <pubDate>Wed, 15 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>/article/2021/12/15/multiple-return-values-research/</guid>
      <description>I have recently been thinking about multiple return values as a concept, and wondering if there has been any kind of literature into the topic of &amp;ldquo;true&amp;rdquo; multiple return values which are not emulated through tuples. My current working hypothesis is that I think I have come to the conclusion (unless there is evidence to the contrary) Odin has invented a new kind of type system, something to the akin of polyadic expressions.</description>
    </item>
    
    <item>
      <title>The Value Propagation Experiment Part 2</title>
      <link>/article/2021/09/06/value-propagation-experiment-part-2/</link>
      <pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/article/2021/09/06/value-propagation-experiment-part-2/</guid>
      <description>**[Originally from a Twitter Thread]**
I have revisited The Value Propagation Experiment and have come to a different conclusion as to why it failed and how I recovered it.
The recovery work has been merged into master now with this PR: https://github.com/odin-lang/Odin/pull/1082
I think there were three things which were confusing which make it look like a failure of an experiment:
try was a confusing name for what the semantics were.</description>
    </item>
    
    <item>
      <title>The Value Propagation Experiment</title>
      <link>/article/2021/07/05/value-propagation-experiment/</link>
      <pubDate>Mon, 05 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>/article/2021/07/05/value-propagation-experiment/</guid>
      <description>[Originally from a Twitter Thread]
Part 2 of this Experiment
The Idea I recently experimented with adding a feature into Odin which allowed for a way to propagate a value by early returning if that value was false or not nil. It was in a similar vein to Rust&amp;rsquo;s try! which became ?, or Zig&amp;rsquo;s try, etc.
I have now removed it from Odin. But why?
The Problem The hypothesis was that that this idiom was common:</description>
    </item>
    
    <item>
      <title>Untyped Types</title>
      <link>/article/2021/03/07/untyped-types/</link>
      <pubDate>Sun, 07 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/article/2021/03/07/untyped-types/</guid>
      <description>When I was designing the constant value system in Odin, I wanted literals (especially numbers) to &amp;ldquo;just work&amp;rdquo;. I was inspired by how both Ada1 and Go2 both handled their constant value systems. But this lead me to a realization that there are two general different models of thought when it comes to values in programming languages.
Model-1: Expressions have a type, not all expressions may have a value. Therefore all values must have a type.</description>
    </item>
    
    <item>
      <title>Relative Pointers</title>
      <link>/article/2020/05/17/relative-pointers/</link>
      <pubDate>Sun, 17 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/article/2020/05/17/relative-pointers/</guid>
      <description>Absolute Pointers Pointers are a value type in programming languages that store a memory address. A pointer references a location in memory, and obtaining the value stored at this location in memory is known as dereferencing a pointer. Pointers are part and parcel of using languages like C, and are an extremely powerful tool. Pointers can be treated as a form of reference type, a value that refers to another typed value in memory.</description>
    </item>
    
    <item>
      <title>A Reply to _Let&#39;s stop copying C_</title>
      <link>/article/2020/01/25/a-reply-to-lets-stop-copying-c/</link>
      <pubDate>Sat, 25 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/article/2020/01/25/a-reply-to-lets-stop-copying-c/</guid>
      <description>I read the article Let&amp;rsquo;s stop copying C about 3 years ago. Recently someone brought it up again and I thought I would comment on the points being made. The article argues that newer languages ought not to copy the mistakes of C and comment on may of C&amp;rsquo;s mistakes.
I recommend reading the original article first before reading this one as I will be commenting directly on the subsections of the article.</description>
    </item>
    
    <item>
      <title>A Discussion Regarding the Design of Imports in Odin</title>
      <link>/transcript/odin-import-design-discussion/</link>
      <pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/transcript/odin-import-design-discussion/</guid>
      <description>This is an partially edited transcript from 2019-05-18 on the Handmade.Network Discord server.
[18:42] lipid: I have a package with my extra math stuff at shared:lipid/math, but I also import core:math. The package name in lipid/math is &#34;lipid_math&#34;, not &#34;math&#34;, but it gives me Redeclaration of &#39;math&#39; in this scope on that line&#34;[18:42] lipid: renaming the folder solves the issue[18:43] gingerBill: @lipid Just rename the package name, it can be anything.</description>
    </item>
    
    <item>
      <title>Exceptions --- And Why Odin Will Never Have Them</title>
      <link>/article/2018/09/05/exceptions---and-why-odin-will-never-have-them/</link>
      <pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/article/2018/09/05/exceptions---and-why-odin-will-never-have-them/</guid>
      <description>Article was originally posted here: https://odin.handmade.network/blogs/p/3372-exceptions_-_and_why_odin_will_never_have_them
Original Comments:
https://github.com/odin-lang/Odin/issues/256#issuecomment-418073701 https://github.com/odin-lang/Odin/issues/256#issuecomment-418289626 There will never be software exceptions in the traditional sense. I hate the entire philosophy behind the concept. Go does have exceptions with the defer, panic, recover approach. They are weird on purpose. Odin could have something similar for exceptional cases. You can the exact same semantics as a try except block by using a switch in statement. The same is true in Go.</description>
    </item>
    
    <item>
      <title>On the Aesthetics of the Syntax of Declarations</title>
      <link>/article/2018/03/12/on-the-aesthetics-of-the-syntax-of-declarations/</link>
      <pubDate>Mon, 12 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/article/2018/03/12/on-the-aesthetics-of-the-syntax-of-declarations/</guid>
      <description>Article was originally posted here: https://odin.handmade.network/blogs/p/2994-on_the_aesthetics_of_the_syntax_of_declarations
n.b. This is a philosophical article and not a technical article. There are no correct answers to the questions that I will pose &amp;ndash; only compromises.
I&amp;rsquo;m considering what the &amp;ldquo;best&amp;rdquo; declaration syntax would be. Historically, there have been two categories: which I will call qualifier-focused and type-focused. An example of qualifier-focused would be the Pascal family. An example of type-focused would be the C family.</description>
    </item>
    
    <item>
      <title>The Metaprogramming Dilemma</title>
      <link>/article/2016/12/01/the-metaprogramming-dilemma/</link>
      <pubDate>Thu, 01 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/article/2016/12/01/the-metaprogramming-dilemma/</guid>
      <description>Article was originally posted here: https://odin.handmade.network/blogs/p/1723-the_metaprogramming_dilemma
Designing this language has been difficult but fun. Two of the original goals of this language were simplicity and metaprogramming however, these together could be an oxymoron. But before I explain why, I first need to explain what I mean by &amp;ldquo;metaprogramming&amp;rdquo;.
Metaprogramming is an &amp;ldquo;art&amp;rdquo; of writing programs to treats other programs as their data. This means that a program could generate, read, analyse, and transform code or even itself to achieve a certain solution.</description>
    </item>
    
  </channel>
</rss>
